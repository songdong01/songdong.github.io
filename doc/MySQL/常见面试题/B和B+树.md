# B树
B树和传统的二查查找树有两个显著的不同：
* 第一个就是B树每一个节点会有多个键值对，键是索引值和指针，value是存储的数据。
* 第二个就是B树是一个自平衡树，左孩子和右孩子的高度是一致的，这样就避免了在极端情况下退化为链表。



**B树的特性**

1.是一个自平衡的树，所有的叶子节点在同一层。  


2.所有的key都是有序，子节点包含了k1和k2之间的全部的key。    


3.B树的增长和搜索是从根节点开始的。当 B 树的一个节点因为插入操作而超过了最大键数（即 ( 2t-1 )），
这个节点会分裂成两个节点，并将中间的键上升到父节点。如果该节点是根节点，分裂会导致树高度的增加，
因为会创建一个新的根节点来容纳上升的键。这意味着 B 树是从根部向上增长的。  

4.B树的插入只发生在叶子节点中。
<details>
<summary>点击以展开/折叠内容</summary>

B树中节点的插入只发生在叶子节点上，这是因为 B 树的设计旨在确保树的平衡性和有效的磁盘I/O操作。以下是插入操作只在叶子节点进行的原因：

**平衡性**：B树是一种自平衡树，它保持所有叶子节点在同一层级上。通过只在叶子节点插入，我们可以确保树的高度尽可能低，从而保持树的平衡性和搜索效率。


**最小填充要求**：B树的每个节点（除根节点外）都有最小和最大键数的要求。插入操作开始时，我们沿着树向下搜索合适的叶子节点，直到找到可以插入新键的位置。这个过程中，如果遇到需要分裂的节点，会立即进行处理，从而保证在到达叶子节点时，树的中间节点都满足最小填充要求。


**分裂操作**：当叶子节点因为插入而超过了最大键数时，会进行分裂操作，创建新的节点，并将中间的键上升到父节点。如果父节点也超过了最大键数，这个过程会继续向上递归，直到根节点。这种自底向上的调整机制有助于保持树的平衡。


**磁盘I/O优化**：B树最初是为磁盘存储而设计的数据结构，节点通常对应磁盘上的一个块。通过在叶子节点进行插入，我们可以减少磁盘读写次数，因为不需要频繁地加载和存储非叶子节点。

**简化算法**：总是在叶子节点插入简化了插入算法的实现。因为所有的插入操作都在叶子节点完成，所以不需要在内部节点中移动数据来为新键腾出空间。

总之，B树的设计目的是为了保持树的平衡，同时优化磁盘存储和读写效率。始终在叶子节点进行插入是实现这些目标的一种有效方法。.

</details>

**B树的构成**

1.键：包含一组有序的键，用于指导搜索操作。在一个有 ( k ) 个键的节点中，键会被存储为 ( K_1, K_2, ..., K_k )，并且满足 ( K_1 < K_2 < ... < K_k )。

2.子节点指针：每个节点包含一组子节点指针，其数量总是比节点中的键的数量多一个。对于节点中的每个键 ( K_i )，
它的左侧子节点指针指向的子树中所有的键都小于 ( K_i )，右侧子节点指针指向的子树中所有的键都大于或等于 ( K_i )。

3.数据指针：在某些B树的实现中，叶子节点可能还包含数据指针，指向实际的数据记录。
```
import java.util.ArrayList;
import java.util.List;

class BTreeNode {
    int t;  // 最小度数
    List<Integer> keys;  // 节点的键
    List<BTreeNode> children;  // 子节点指针
    boolean isLeaf;  // 是否为叶子节点
    int keyCount;  // 节点中的键的数量

    public BTreeNode(int t, boolean isLeaf) {
        this.t = t;
        this.isLeaf = isLeaf;
        this.keys = new ArrayList<>(2 * t - 1);
        this.children = new ArrayList<>(2 * t);
        this.keyCount = 0;
    }
}

```
![image](https://github.com/songdong01/songdong.github.io/assets/55269887/b0ec16c4-6bf1-463b-8f1d-9240738979af)

上面是一个B树的构成，所有的叶子节点都有相同的层级，在每一层中指针数量等于key值数量加1。
